/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace IConfigurable {
  export type TokenConfigStruct = {
    minMarginPerLiquidityPosition: PromiseOrValue<BigNumberish>;
    maxRiskRatePerLiquidityPosition: PromiseOrValue<BigNumberish>;
    maxLeveragePerLiquidityPosition: PromiseOrValue<BigNumberish>;
    minMarginPerPosition: PromiseOrValue<BigNumberish>;
    maxLeveragePerPosition: PromiseOrValue<BigNumberish>;
    liquidationFeeRatePerPosition: PromiseOrValue<BigNumberish>;
    liquidationExecutionFee: PromiseOrValue<BigNumberish>;
    interestRate: PromiseOrValue<BigNumberish>;
    maxFundingRate: PromiseOrValue<BigNumberish>;
  };

  export type TokenConfigStructOutput = [
    BigNumber,
    number,
    number,
    BigNumber,
    number,
    number,
    BigNumber,
    number,
    number
  ] & {
    minMarginPerLiquidityPosition: BigNumber;
    maxRiskRatePerLiquidityPosition: number;
    maxLeveragePerLiquidityPosition: number;
    minMarginPerPosition: BigNumber;
    maxLeveragePerPosition: number;
    liquidationFeeRatePerPosition: number;
    liquidationExecutionFee: BigNumber;
    interestRate: number;
    maxFundingRate: number;
  };

  export type TokenFeeRateConfigStruct = {
    tradingFeeRate: PromiseOrValue<BigNumberish>;
    liquidityFeeRate: PromiseOrValue<BigNumberish>;
    protocolFeeRate: PromiseOrValue<BigNumberish>;
    referralReturnFeeRate: PromiseOrValue<BigNumberish>;
    referralParentReturnFeeRate: PromiseOrValue<BigNumberish>;
    referralDiscountRate: PromiseOrValue<BigNumberish>;
  };

  export type TokenFeeRateConfigStructOutput = [
    number,
    number,
    number,
    number,
    number,
    number
  ] & {
    tradingFeeRate: number;
    liquidityFeeRate: number;
    protocolFeeRate: number;
    referralReturnFeeRate: number;
    referralParentReturnFeeRate: number;
    referralDiscountRate: number;
  };

  export type VertexConfigStruct = {
    balanceRate: PromiseOrValue<BigNumberish>;
    premiumRate: PromiseOrValue<BigNumberish>;
  };

  export type VertexConfigStructOutput = [number, number] & {
    balanceRate: number;
    premiumRate: number;
  };

  export type TokenPriceConfigStruct = {
    maxPriceImpactLiquidity: PromiseOrValue<BigNumberish>;
    liquidationVertexIndex: PromiseOrValue<BigNumberish>;
    vertices: IConfigurable.VertexConfigStruct[];
  };

  export type TokenPriceConfigStructOutput = [
    BigNumber,
    number,
    IConfigurable.VertexConfigStructOutput[]
  ] & {
    maxPriceImpactLiquidity: BigNumber;
    liquidationVertexIndex: number;
    vertices: IConfigurable.VertexConfigStructOutput[];
  };
}

export interface IConfigurableInterface extends utils.Interface {
  functions: {
    "USD()": FunctionFragment;
    "enableToken(address,(uint64,uint32,uint32,uint64,uint32,uint32,uint64,uint32,uint32),(uint32,uint32,uint32,uint32,uint32,uint32),(uint128,uint8,(uint32,uint32)[]))": FunctionFragment;
    "isEnabledToken(address)": FunctionFragment;
    "tokenConfigs(address)": FunctionFragment;
    "tokenFeeRateConfigs(address)": FunctionFragment;
    "tokenPriceConfigs(address)": FunctionFragment;
    "tokenPriceVertexConfigs(address,uint8)": FunctionFragment;
    "updateTokenConfig(address,(uint64,uint32,uint32,uint64,uint32,uint32,uint64,uint32,uint32),(uint32,uint32,uint32,uint32,uint32,uint32),(uint128,uint8,(uint32,uint32)[]))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "USD"
      | "enableToken"
      | "isEnabledToken"
      | "tokenConfigs"
      | "tokenFeeRateConfigs"
      | "tokenPriceConfigs"
      | "tokenPriceVertexConfigs"
      | "updateTokenConfig"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "USD", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "enableToken",
    values: [
      PromiseOrValue<string>,
      IConfigurable.TokenConfigStruct,
      IConfigurable.TokenFeeRateConfigStruct,
      IConfigurable.TokenPriceConfigStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isEnabledToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenConfigs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenFeeRateConfigs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenPriceConfigs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenPriceVertexConfigs",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenConfig",
    values: [
      PromiseOrValue<string>,
      IConfigurable.TokenConfigStruct,
      IConfigurable.TokenFeeRateConfigStruct,
      IConfigurable.TokenPriceConfigStruct
    ]
  ): string;

  decodeFunctionResult(functionFragment: "USD", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "enableToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isEnabledToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenFeeRateConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenPriceConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenPriceVertexConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenConfig",
    data: BytesLike
  ): Result;

  events: {
    "TokenConfigChanged(address,tuple,tuple,tuple)": EventFragment;
    "USDEnabled(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "TokenConfigChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "USDEnabled"): EventFragment;
}

export interface TokenConfigChangedEventObject {
  token: string;
  newCfg: IConfigurable.TokenConfigStructOutput;
  newFeeRateCfg: IConfigurable.TokenFeeRateConfigStructOutput;
  newPriceCfg: IConfigurable.TokenPriceConfigStructOutput;
}
export type TokenConfigChangedEvent = TypedEvent<
  [
    string,
    IConfigurable.TokenConfigStructOutput,
    IConfigurable.TokenFeeRateConfigStructOutput,
    IConfigurable.TokenPriceConfigStructOutput
  ],
  TokenConfigChangedEventObject
>;

export type TokenConfigChangedEventFilter =
  TypedEventFilter<TokenConfigChangedEvent>;

export interface USDEnabledEventObject {
  usd: string;
}
export type USDEnabledEvent = TypedEvent<[string], USDEnabledEventObject>;

export type USDEnabledEventFilter = TypedEventFilter<USDEnabledEvent>;

export interface IConfigurable extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IConfigurableInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    USD(overrides?: CallOverrides): Promise<[string]>;

    enableToken(
      token: PromiseOrValue<string>,
      cfg: IConfigurable.TokenConfigStruct,
      feeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      priceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isEnabledToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    tokenConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        number,
        number,
        BigNumber,
        number,
        number,
        BigNumber,
        number,
        number
      ] & {
        minMarginPerLiquidityPosition: BigNumber;
        maxRiskRatePerLiquidityPosition: number;
        maxLeveragePerLiquidityPosition: number;
        minMarginPerPosition: BigNumber;
        maxLeveragePerPosition: number;
        liquidationFeeRatePerPosition: number;
        liquidationExecutionFee: BigNumber;
        interestRate: number;
        maxFundingRate: number;
      }
    >;

    tokenFeeRateConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, number, number, number, number] & {
        tradingFeeRate: number;
        liquidityFeeRate: number;
        protocolFeeRate: number;
        referralReturnFeeRate: number;
        referralParentReturnFeeRate: number;
        referralDiscountRate: number;
      }
    >;

    tokenPriceConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number] & {
        maxPriceImpactLiquidity: BigNumber;
        liquidationVertexIndex: number;
      }
    >;

    tokenPriceVertexConfigs(
      token: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number, number] & { balanceRate: number; premiumRate: number }>;

    updateTokenConfig(
      token: PromiseOrValue<string>,
      newCfg: IConfigurable.TokenConfigStruct,
      newFeeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      newPriceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  USD(overrides?: CallOverrides): Promise<string>;

  enableToken(
    token: PromiseOrValue<string>,
    cfg: IConfigurable.TokenConfigStruct,
    feeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
    priceCfg: IConfigurable.TokenPriceConfigStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isEnabledToken(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  tokenConfigs(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      number,
      number,
      BigNumber,
      number,
      number,
      BigNumber,
      number,
      number
    ] & {
      minMarginPerLiquidityPosition: BigNumber;
      maxRiskRatePerLiquidityPosition: number;
      maxLeveragePerLiquidityPosition: number;
      minMarginPerPosition: BigNumber;
      maxLeveragePerPosition: number;
      liquidationFeeRatePerPosition: number;
      liquidationExecutionFee: BigNumber;
      interestRate: number;
      maxFundingRate: number;
    }
  >;

  tokenFeeRateConfigs(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [number, number, number, number, number, number] & {
      tradingFeeRate: number;
      liquidityFeeRate: number;
      protocolFeeRate: number;
      referralReturnFeeRate: number;
      referralParentReturnFeeRate: number;
      referralDiscountRate: number;
    }
  >;

  tokenPriceConfigs(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number] & {
      maxPriceImpactLiquidity: BigNumber;
      liquidationVertexIndex: number;
    }
  >;

  tokenPriceVertexConfigs(
    token: PromiseOrValue<string>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[number, number] & { balanceRate: number; premiumRate: number }>;

  updateTokenConfig(
    token: PromiseOrValue<string>,
    newCfg: IConfigurable.TokenConfigStruct,
    newFeeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
    newPriceCfg: IConfigurable.TokenPriceConfigStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    USD(overrides?: CallOverrides): Promise<string>;

    enableToken(
      token: PromiseOrValue<string>,
      cfg: IConfigurable.TokenConfigStruct,
      feeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      priceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    isEnabledToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        number,
        number,
        BigNumber,
        number,
        number,
        BigNumber,
        number,
        number
      ] & {
        minMarginPerLiquidityPosition: BigNumber;
        maxRiskRatePerLiquidityPosition: number;
        maxLeveragePerLiquidityPosition: number;
        minMarginPerPosition: BigNumber;
        maxLeveragePerPosition: number;
        liquidationFeeRatePerPosition: number;
        liquidationExecutionFee: BigNumber;
        interestRate: number;
        maxFundingRate: number;
      }
    >;

    tokenFeeRateConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, number, number, number, number] & {
        tradingFeeRate: number;
        liquidityFeeRate: number;
        protocolFeeRate: number;
        referralReturnFeeRate: number;
        referralParentReturnFeeRate: number;
        referralDiscountRate: number;
      }
    >;

    tokenPriceConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number] & {
        maxPriceImpactLiquidity: BigNumber;
        liquidationVertexIndex: number;
      }
    >;

    tokenPriceVertexConfigs(
      token: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number, number] & { balanceRate: number; premiumRate: number }>;

    updateTokenConfig(
      token: PromiseOrValue<string>,
      newCfg: IConfigurable.TokenConfigStruct,
      newFeeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      newPriceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "TokenConfigChanged(address,tuple,tuple,tuple)"(
      token?: PromiseOrValue<string> | null,
      newCfg?: null,
      newFeeRateCfg?: null,
      newPriceCfg?: null
    ): TokenConfigChangedEventFilter;
    TokenConfigChanged(
      token?: PromiseOrValue<string> | null,
      newCfg?: null,
      newFeeRateCfg?: null,
      newPriceCfg?: null
    ): TokenConfigChangedEventFilter;

    "USDEnabled(address)"(
      usd?: PromiseOrValue<string> | null
    ): USDEnabledEventFilter;
    USDEnabled(usd?: PromiseOrValue<string> | null): USDEnabledEventFilter;
  };

  estimateGas: {
    USD(overrides?: CallOverrides): Promise<BigNumber>;

    enableToken(
      token: PromiseOrValue<string>,
      cfg: IConfigurable.TokenConfigStruct,
      feeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      priceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isEnabledToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenFeeRateConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenPriceConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenPriceVertexConfigs(
      token: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateTokenConfig(
      token: PromiseOrValue<string>,
      newCfg: IConfigurable.TokenConfigStruct,
      newFeeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      newPriceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    USD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enableToken(
      token: PromiseOrValue<string>,
      cfg: IConfigurable.TokenConfigStruct,
      feeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      priceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isEnabledToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenFeeRateConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenPriceConfigs(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenPriceVertexConfigs(
      token: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateTokenConfig(
      token: PromiseOrValue<string>,
      newCfg: IConfigurable.TokenConfigStruct,
      newFeeRateCfg: IConfigurable.TokenFeeRateConfigStruct,
      newPriceCfg: IConfigurable.TokenPriceConfigStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
